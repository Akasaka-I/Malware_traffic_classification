from scapy.all import rdpcap, IP, TCP, UDP, Ether
from collections import defaultdict
from PIL import Image
import numpy as np
import random


# virusPcap/1clickdownload/VirusShare_2ba75e098cc457af43b196ddf31cfe1b.pcap
def randomize_ip():
    return ".".join(str(random.randint(0, 255)) for _ in range(4))

def randomize_mac():
    return ":".join(["%02x" % random.randint(0, 255) for _ in range(6)])

def extract_flows(pcap_file):
    packets = rdpcap(pcap_file)
    flows = defaultdict(list)

    for packet in packets:
        if packet.haslayer('IP') and (packet.haslayer('TCP') or packet.haslayer('UDP')):
            # Retrieve the source IP, source port, destination IP, destination port, and protocol for the IP layer, each flow is defined by a five-tuple
            flow_tuple = (
            packet['IP'].src, packet['IP'].sport, packet['IP'].dst, packet['IP'].dport, packet['IP'].proto)
            flows[flow_tuple].append(packet)
            
    return flows

def process_flows(flows):
    processed_flows = defaultdict(list)
    for flow_tuple, packets in flows.items():
        mac_mapping = {}
        ip_mapping = {}
        
        for packet in packets:
            if packet.haslayer(Ether):
                src_mac = packet[Ether].src
                dst_mac = packet[Ether].dst
                if src_mac not in mac_mapping:
                    mac_mapping[src_mac] = randomize_mac()
                if dst_mac not in mac_mapping:
                    mac_mapping[dst_mac] = randomize_mac()
                packet[Ether].src = mac_mapping[src_mac]
                packet[Ether].dst = mac_mapping[dst_mac]

            if packet.haslayer(IP):
                src_ip = packet[IP].src
                dst_ip = packet[IP].dst
                if src_ip not in ip_mapping:
                    ip_mapping[src_ip] = randomize_ip()
                if dst_ip not in ip_mapping:
                    ip_mapping[dst_ip] = randomize_ip()
                packet[IP].src = ip_mapping[src_ip]
                packet[IP].dst = ip_mapping[dst_ip]
            
            processed_flows[flow_tuple].append(packet)
    
    return processed_flows